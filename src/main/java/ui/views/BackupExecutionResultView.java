package ui.views;

import fileBackup.backupExecution.*;
import fileBackup.backupExecution.backupTasks.BackupTaskError;
import fileBackup.backupExecution.backupTasks.DeleteDirectoryTaskResult;
import fileBackup.fileAnalysis.FileAccessError;
import fileBackup.fileAnalysis.FileChangeRecord;
import fileBackup.fileAnalysis.TimeUtils;
import io.vavr.control.Either;
import javafx.beans.property.SimpleStringProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.Scene;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.util.Duration;
import ui.utils.ObservableListCollector;
import ui.controls.StageUtils;
import ui.controls.ControlUtil;
import ui.controls.FormattedTableView;
import ui.controls.StyledVBox;
import ui.tableCells.TableCellButton;
import ui.tableCells.TableCellFactory;
import ui.tasks.TaskFailureError;

import java.util.Comparator;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.ToIntFunction;

/**
 * Displays the results from the backup execution generated by running a {@code BackupTask} by invoking
 * a {@code BackupExecutor}.
 *
 * <p>Lots of information is generated from executing a backup with summary views displayed to begin with
 * and allowing the user to drill down to see more detailed information of the exact backup steps taken along
 * with any errors.</p>
 *
 * Created by matt on 09-Jul-17.
 */
public class BackupExecutionResultView extends StyledVBox {

    public BackupExecutionResultView(Either<TaskFailureError, BackupExecutionResult> eitherBackupExecutionResult) {

        // When BackupActionView invokes BackupExecutionTask and setOnFailed is triggered.
        if (eitherBackupExecutionResult.isLeft()) {
            getChildren().add(ControlUtil.getBasicErrorComponent(eitherBackupExecutionResult.getLeft().getError()));
            return;
        }

        // BackupExecutionTask CompletableFuture exceptionally triggered.
        BackupExecutionResult backupExecutionResult = eitherBackupExecutionResult.get();
        if (backupExecutionResult.getError().isPresent()) {
            getChildren().add(ControlUtil.getBasicErrorComponent(backupExecutionResult.getError().get()));
            return;
        }

        ObservableList<BackupOperation> singleBackupOperations = getSingleBackupOperations(backupExecutionResult);
        ObservableList<DeleteDirectoryTaskResult> deleteDirectoryTaskResults = backupExecutionResult
                .getCompletedDeletionBackup()
                .getCompletedDirectoryDeletions()
                .getDirectoryDeletions().stream().collect(new ObservableListCollector<>());

        if (singleBackupOperations.isEmpty() && deleteDirectoryTaskResults.isEmpty()) {
            // Technically should never happen since BackupActionView only executes backup if there are pending files.
            getChildren().add(ControlUtil.getBasicErrorComponent("There are no backup execution results to display"));
            return;
        }

        /*
         * The landing view contains 2 root views displaying the results of performing the single backup operations
         * (Anything other than an entire directory deletion) and any complete directory deletions.
         * Each view is only displayed if there exists records.
         *
         * Within each of these views you can drill down to explore the finer details of each backup operation stage
         * as well as any errors.
         */
        TitledPane singleBackupOperationsPane = new TitledPane();
        if (!singleBackupOperations.isEmpty()) {
            singleBackupOperationsPane.setText("Single file backup execution results (" + singleBackupOperations.size() + ")");
            singleBackupOperationsPane.setExpanded(false);
            singleBackupOperationsPane.setContent(new BackupOperationTableView(singleBackupOperations));
            HBox.setHgrow(singleBackupOperationsPane, Priority.ALWAYS);

            getChildren().add(singleBackupOperationsPane);
            ControlUtil.fadeIn(singleBackupOperationsPane);
        }

        TitledPane deleteDirectoryTaskPane = new TitledPane();
        if (!deleteDirectoryTaskResults.isEmpty()) {
            deleteDirectoryTaskPane.setText("Deleted directory backup execution results (" + deleteDirectoryTaskResults.size() + ")");
            deleteDirectoryTaskPane.setExpanded(false);
            deleteDirectoryTaskPane.setContent(new DeleteDirectoryTaskTableView(deleteDirectoryTaskResults));
            HBox.setHgrow(deleteDirectoryTaskPane, Priority.ALWAYS);

            getChildren().add(deleteDirectoryTaskPane);
            ControlUtil.fadeIn(deleteDirectoryTaskPane);
        }

        // Expand panes once populated for ui feedback
        ControlUtil.doAfterDelay(Duration.millis(500), e -> {
            if (!singleBackupOperations.isEmpty()) {
                singleBackupOperationsPane.setExpanded(true);
            }
            if (!deleteDirectoryTaskResults.isEmpty()) {
                deleteDirectoryTaskPane.setExpanded(true);
            }
        });

    }

    /**
     * Gets the data to be displayed in {@code BackupOperationTableView} located within the
     * 'Single file backup execution pane'. This is a combination of the modified/new and single file deletion
     * backup execution results (anything other than a complete directory deletion).
     *
     * <p>Directory deletion is handled separately as a this has 'many' sub deletions which can't be merged nicely
     * into this list so for clarity it is put in a separate table.</p>
     *
     * @param backupExecutionResult the {@code BackupExecutionResult}.
     * @return The combined modified/new file backup and single file deletion backup results.
     */
    private ObservableList<BackupOperation> getSingleBackupOperations(BackupExecutionResult backupExecutionResult) {
        ObservableList<BackupOperation> modifiedOperations = backupExecutionResult
                .getCompletedModifiedFilesBackup()
                .getResults().stream().collect(new ObservableListCollector<>());

        List<BackupOperation> singleFileDeletions = backupExecutionResult
                .getCompletedDeletionBackup()
                .getCompletedSingleFileDeletions()
                .getSingleFileDeletions();

        modifiedOperations.addAll(singleFileDeletions);
        return modifiedOperations;
    }

    /**
     * A {@code TableView} to display {@code BackupOperation}s. This can be reused for for both the single file
     * backup execution view and for the details of the deleted directory view where each deleted file in the directory
     * is a {@code BackupOperation}.
     */
    private class BackupOperationTableView extends FormattedTableView<BackupOperation> {

        public BackupOperationTableView(ObservableList<BackupOperation> backupOperations) {
            TableColumn<BackupOperation, String> statusColumn = new TableColumn<>("Status");
            statusColumn.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getFileBackupStatus().getDescription()));
            statusColumn.setCellFactory(param -> TableCellFactory.backupOperationExecutionStatusTableCell());

            TableColumn<BackupOperation, String> fileSystemActionColumn = new TableColumn<>("File System Action");
            fileSystemActionColumn.setCellValueFactory(param ->
                    new SimpleStringProperty(param.getValue().getFileChangeRecord().getFileSystemAction().getDescription()));
            fileSystemActionColumn.setCellFactory(param -> TableCellFactory.backupOperationFileSystemActionTableCell());

            TableColumn<BackupOperation, String> fileTypeColumn = new TableColumn<>("File Type");
            fileTypeColumn.setCellValueFactory(param ->
                    new SimpleStringProperty(param.getValue().getFileChangeRecord().getFileType().getDescription()));
            fileTypeColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<BackupOperation, String> backupPathColumn = new TableColumn<>("Backup Path");
            backupPathColumn.setCellValueFactory(param ->
                    new SimpleStringProperty(param.getValue().getFileChangeRecord().getBackupPath().toString()));
            backupPathColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<BackupOperation, String> totalStagesColumn = new TableColumn<>("Total Stages");
            totalStagesColumn.setCellValueFactory(param ->
                    new SimpleStringProperty(param.getValue().getBackupTaskExecutionPipeline().getBackupStages().size() + ""));
            totalStagesColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<BackupOperation, String> viewDetailsColumn = new TableColumn<>("Details");
            viewDetailsColumn.setCellValueFactory(param -> new SimpleStringProperty("View"));
            viewDetailsColumn.setCellFactory(param -> {
                Consumer<BackupOperation> onAction = backupOperation -> {
                    Stage stage = new Stage();
                    stage.initModality(Modality.APPLICATION_MODAL);
                    Scene scene = new Scene(new SingleFileBackupExecutionDetailView(backupOperation));
                    stage.setScene(scene);
                    stage.setTitle("Backup execution detail");
                    stage.getIcons().add(StageUtils.getInstance().getLogo());
                    scene.getStylesheets().add(getClass().getResource("/styles.css").toExternalForm());
                    stage.setWidth(StageUtils.getInstance().scaleWidth(0.8));
                    stage.setHeight(StageUtils.getInstance().scaleHeight(0.3));
                    ControlUtil.fadeIn(scene.getRoot());
                    stage.showAndWait();
                };
                Predicate<BackupOperation> isEnabled = backupOperation1 -> true;
                return new TableCellButton<>("View", onAction, isEnabled);
            });

            setItems(backupOperations);

            getColumns().add(statusColumn);
            getColumns().add(fileSystemActionColumn);
            getColumns().add(fileTypeColumn);
            getColumns().add(backupPathColumn);
            getColumns().add(totalStagesColumn);
            getColumns().add(viewDetailsColumn);
        }
    }


    /**
     * A {@code BackupOperation} can consist of many backup stages which are completed within a
     * {@code BackupTaskExecutionPipeline}. This view therefore exists to drill down from the higher level
     * {@code BackupOperation} displayed in {@code BackupOperationTableView}.
     */
    private class SingleFileBackupExecutionDetailView extends StyledVBox {

        public SingleFileBackupExecutionDetailView(BackupOperation backupOperation) {

            TableColumn<BackupTaskResult, String> statusColumn = new TableColumn<>("Status");
            statusColumn.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getFileBackupStatus().getDescription()));
            statusColumn.setCellFactory(param -> TableCellFactory.backupTaskResultFileBackupStatusTableCell());

            TableColumn<BackupTaskResult, String> taskDescriptionColumn = new TableColumn<>("Task Description");
            taskDescriptionColumn.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getBackupTask().getTaskDescription()));
            taskDescriptionColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<BackupTaskResult, String> commitTimeColumn = new TableColumn<>("Commit Time");
            commitTimeColumn.setCellValueFactory(param -> new SimpleStringProperty(TimeUtils.format(param.getValue().getBackupCommitTime())));
            commitTimeColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<BackupTaskResult, String> fileTypeColumn = new TableColumn<>("File Type");
            fileTypeColumn.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getFileChangeRecord().getFileType().getDescription()));
            fileTypeColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<BackupTaskResult, String> currentPathColumn = new TableColumn<>("Current Path");
            currentPathColumn.setCellValueFactory(param -> param.getValue().getFileChangeRecord().getCurrentWorkingPath()
                    .map(path -> new SimpleStringProperty(path.toString()))
                    .orElseGet(() -> new SimpleStringProperty("")));
            currentPathColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<BackupTaskResult, String> backupPathColumn = new TableColumn<>("Backup Path");
            backupPathColumn.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getFileChangeRecord().getBackupPath().toString()));
            backupPathColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<BackupTaskResult, String> errorColumn = new TableColumn<>("Error Reason");
            errorColumn.setCellValueFactory(param -> param.getValue().getErrorReason()
                    .map(SimpleStringProperty::new)
                    .orElseGet(() -> new SimpleStringProperty("")));
            errorColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            // Show failures first as they are more important for the user to see.
            ToIntFunction<BackupTaskResult> sortedBy = task -> task.getFileBackupStatus() == FileBackupStatus.FAILURE ? -1 : 1;

            ObservableList<BackupTaskResult> backupStages = backupOperation
                    .getBackupTaskExecutionPipeline()
                    .getBackupStages().stream()
                    .sorted(Comparator.comparingInt(sortedBy))
                    .collect(new ObservableListCollector<>());

            FormattedTableView<BackupTaskResult> tableView = new FormattedTableView<>();

            tableView.setItems(backupStages);

            tableView.getColumns().add(statusColumn);
            tableView.getColumns().add(taskDescriptionColumn);
            tableView.getColumns().add(commitTimeColumn);
            tableView.getColumns().add(fileTypeColumn);
            tableView.getColumns().add(currentPathColumn);
            tableView.getColumns().add(backupPathColumn);
            tableView.getColumns().add(errorColumn);

            String title = "Backup execution stages (" + backupOperation.getBackupTaskExecutionPipeline().getBackupStages().size() + ")";
            TitledPane pane = new TitledPane(title, tableView);
            pane.setExpanded(false);

            getChildren().add(pane);

            ControlUtil.doAfterDelay(Duration.millis(500), e -> pane.setExpanded(true));
        }
    }

    /**
     * Root view to display the highest summary of any deleted directories as a result of running the
     * {@code DeleteDirectoryTask}.
     *
     * <p>A 'details' column provides a button which opens another view depending on whether there was an error.
     * If {@code DeleteDirectoryTask} failed to execute, {@code BackupTaskErrorTableView} is displayed.
     * Otherwise {@code DeletedDirectoryDetailsView} displays the complete breakdown of all the files deleted
     * in the directory plus any errors.</p>
     */
    private class DeleteDirectoryTaskTableView extends FormattedTableView<DeleteDirectoryTaskResult> {

        private DeleteDirectoryTaskTableView(ObservableList<DeleteDirectoryTaskResult> deleteDirectoryTaskResults) {

            TableColumn<DeleteDirectoryTaskResult, String> statusColumn = new TableColumn<>("Status");
            statusColumn.setCellValueFactory(param -> {
                if (param.getValue().isValid()) {
                    return new SimpleStringProperty("Success");
                }
                return new SimpleStringProperty("Failed");
            });
            statusColumn.setCellFactory(param -> TableCellFactory.deleteDirectoryTaskResultTableCell());

            TableColumn<DeleteDirectoryTaskResult, String> rootDirectoryPathColumn = new TableColumn<>("Root Directory");
            rootDirectoryPathColumn.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getStartingRootRecord().getBackupPath().toString()));
            rootDirectoryPathColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<DeleteDirectoryTaskResult, String> filesDeletedColumn = new TableColumn<>("Files Deleted");
            filesDeletedColumn.setCellValueFactory(param -> {
                Either<BackupTaskError, FileWalkBackupOperation> result = param.getValue().getResult();
                if (result.isLeft()) {
                    return new SimpleStringProperty("0");
                }
                return new SimpleStringProperty(result.get().getBackupOperations().size() + "");
            });
            filesDeletedColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<DeleteDirectoryTaskResult, String> relatingErrorsColumn = new TableColumn<>("Detected Errors");
            relatingErrorsColumn.setCellValueFactory(param -> {
                Either<BackupTaskError, FileWalkBackupOperation> result = param.getValue().getResult();
                if (result.isLeft()) {
                    return new SimpleStringProperty("1");
                }
                return new SimpleStringProperty(result.get().getFileAccessErrors().size() + "");
            });
            relatingErrorsColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());


            TableColumn<DeleteDirectoryTaskResult, String> viewDetailsColumn = new TableColumn<>("Details");
            viewDetailsColumn.setCellValueFactory(param -> new SimpleStringProperty("View"));
            viewDetailsColumn.setCellFactory(param -> {
                Consumer<DeleteDirectoryTaskResult> onAction = deleteDirectoryTaskResult -> {


                    Either<BackupTaskError, FileWalkBackupOperation> result = deleteDirectoryTaskResult.getResult();
                    if (result.isLeft()) {
                        // DeleteDirectoryTaskResult could not execute
                        Stage stage = new Stage();
                        stage.initModality(Modality.APPLICATION_MODAL);
                        Scene scene = new Scene(new BackupTaskErrorTableView(result.getLeft()));
                        stage.setScene(scene);
                        stage.setTitle("Error detail");
                        stage.getIcons().add(StageUtils.getInstance().getLogo());
                        scene.getStylesheets().add(getClass().getResource("/styles.css").toExternalForm());

                        stage.setWidth(StageUtils.getInstance().scaleWidth(0.8));
                        stage.setHeight(StageUtils.getInstance().scaleHeight(0.6));
                        ControlUtil.fadeIn(scene.getRoot());
                        stage.showAndWait();
                    } else {
                        // DeleteDirectoryTaskResult did execute and here are the results
                        Stage stage = new Stage();
                        stage.initModality(Modality.APPLICATION_MODAL);
                        Scene scene = new Scene(new DeletedDirectoryDetailsView(result.get()));
                        stage.setScene(scene);
                        stage.setTitle("Deleted directory details");
                        stage.getIcons().add(StageUtils.getInstance().getLogo());
                        scene.getStylesheets().add(getClass().getResource("/styles.css").toExternalForm());

                        stage.setWidth(StageUtils.getInstance().scaleWidth(0.8));
                        stage.setHeight(StageUtils.getInstance().scaleHeight(0.6));
                        ControlUtil.fadeIn(scene.getRoot());
                        stage.showAndWait();
                    }
                };
                Predicate<DeleteDirectoryTaskResult> isEnabled = backupOperation1 -> true;
                return new TableCellButton<>("View", onAction, isEnabled);
            });

            getColumns().add(statusColumn);
            getColumns().add(rootDirectoryPathColumn);
            getColumns().add(filesDeletedColumn);
            getColumns().add(relatingErrorsColumn);
            getColumns().add(viewDetailsColumn);

            setItems(deleteDirectoryTaskResults);
        }
    }


    /**
     * TableView to display a single {@code BackupTaskError}. A table is used because it looks nicer and keeps the
     * ui views consistent even if there is only 1 row.
     */
    private class BackupTaskErrorTableView extends FormattedTableView<BackupTaskError> {

        private BackupTaskErrorTableView(BackupTaskError backupTaskError) {
            TableColumn<BackupTaskError, String> backupPathColumn = new TableColumn<>("Backup Task");
            backupPathColumn.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getBackupTask().getTaskDescription()));
            backupPathColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<BackupTaskError, String> reasonColumn = new TableColumn<>("Reason");
            reasonColumn.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getReason()));
            reasonColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            getColumns().add(backupPathColumn);
            getColumns().add(reasonColumn);

            setItems(FXCollections.observableArrayList(backupTaskError));
        }
    }

    /**
     * Displays all {@code BackupOperation}s corresponding to a file that was deleted within the entire directory delete.
     *
     * <p>If there are errors, an additional error pane is displayed.</p>
     */
    private class DeletedDirectoryDetailsView extends StyledVBox {

        private DeletedDirectoryDetailsView(FileWalkBackupOperation fileWalkBackupOperation) {

            List<FileAccessError> fileAccessErrors = fileWalkBackupOperation.getFileAccessErrors();

            /*
             * The BackupOperations in fileWalkBackupOperation.getBackupOperations() refer to the parent directory
             * being deleted, NOT the actual file within this directory. It's simple to get access to the actual file
             * deleted by getting the first FileChangeRecord that was executed in the BackupTaskExecutionPipeline.
             * There will always be at least 1 element in the pipeline.
             *
             * If the user wants to drill down further in the UI, the view details button will lead them to the
             * same file information but it will contain all stages from this point on as well as the BackupTask
             * that performed the execution.
             */
            Function<BackupOperation, BackupOperation> mapToDeletedFile = operation -> {
                BackupTaskResult backupTaskResult = operation.getBackupTaskExecutionPipeline().getBackupStages().get(0);
                FileChangeRecord fileChangeRecord = backupTaskResult.getFileChangeRecord();
                return BackupOperation.of(fileChangeRecord, operation.getBackupTaskExecutionPipeline());
            };

            ObservableList<BackupOperation> backupOperations = fileWalkBackupOperation.getBackupOperations().stream()
                    .map(mapToDeletedFile)
                    .collect(new ObservableListCollector<>());

            TitledPane deletedFilesInDirectoryPane = null;
            TitledPane errorPane = null;

            if (!backupOperations.isEmpty()) {
                deletedFilesInDirectoryPane = new TitledPane();
                deletedFilesInDirectoryPane.setText("All deleted files within directory (" + backupOperations.size() + ")");
                deletedFilesInDirectoryPane.setExpanded(false);
                deletedFilesInDirectoryPane.setContent(new BackupOperationTableView(backupOperations));
                HBox.setHgrow(deletedFilesInDirectoryPane, Priority.ALWAYS);
                getChildren().add(deletedFilesInDirectoryPane);
            }

            if (!fileAccessErrors.isEmpty()) {
                errorPane = new TitledPane();
                errorPane.setText("Errors (" + fileAccessErrors.size() + ")");
                errorPane.setExpanded(false);
                errorPane.setContent(new FileAccessErrorTableView(FXCollections.observableArrayList(fileAccessErrors)));
                HBox.setHgrow(errorPane, Priority.ALWAYS);
                getChildren().add(errorPane);
            }

            // Expand panes once populated for ui feedback
            TitledPane finalDeletedFilesInDirectoryPane = deletedFilesInDirectoryPane;
            TitledPane finalErrorPane = errorPane;
            ControlUtil.doAfterDelay(Duration.millis(500), e -> {
                if (!backupOperations.isEmpty() && finalDeletedFilesInDirectoryPane != null) {
                    finalDeletedFilesInDirectoryPane.setExpanded(true);
                }
                if (!fileAccessErrors.isEmpty() && finalErrorPane != null) {
                    finalErrorPane.setExpanded(true);
                }
            });
        }
    }
}