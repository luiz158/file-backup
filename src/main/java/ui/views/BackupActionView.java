package ui.views;

import fileBackup.backupExecution.BackupExecutionResult;
import fileBackup.backupExecution.pending.PendingDeletedRecords;
import fileBackup.backupExecution.pending.PendingModifiedRecords;
import fileBackup.fileAnalysis.FileAccessError;
import fileBackup.fileAnalysis.FileAnalysisResult;
import fileBackup.fileAnalysis.FileChangeRecord;
import io.vavr.control.Either;
import javafx.beans.property.SimpleStringProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.util.Duration;
import ui.utils.ObservableListCollector;
import ui.controls.ControlUtil;
import ui.controls.FormattedTableView;
import ui.controls.StyledVBox;
import ui.tableCells.TableCellFactory;
import ui.tasks.BackupExecutionTask;
import ui.tasks.FileBackupExecutorService;
import ui.tasks.FileSystemScanResult;
import ui.tasks.TaskFailureError;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;

/**
 * Displays the results generated from the initial {@code FileSystemScanResult} generated by {@code Collector} classes
 * within the {@code fileAnalysis} package. This view provides the flow into executing the actual backup if
 * eligible files exist.
 *
 * Created by matt on 05-Jul-17.
 */
public class BackupActionView extends StyledVBox {
    /*
     * This view is contained within the center of HomeView so access is needed to swap out the center with
     * another view such as BackupExecutionResultView and to activate the ProgressStatus etc.
     */
    private final HomeView homeView;

    /*
     * Provide access so when backup execution is run we can easily go back in and get the modified and deleted file
     * records rather than having to group them back into modified and deleted records that were aggregated into
     * the single list modifiedAndDeletedFileScanResults.
     */
    private final Either<TaskFailureError, FileSystemScanResult> eitherFileSystemScanResult;
    private Button buttonExecuteBackup;

    private TitledPane fileSystemScanStatisticsPane;
    private TitledPane filesReadyForBackupPane;
    private TitledPane errorPane;

    public BackupActionView(HomeView homeView,
                            Either<TaskFailureError, FileSystemScanResult> eitherFileSystemScanResult) {
        this.homeView = homeView;
        this.eitherFileSystemScanResult = eitherFileSystemScanResult;

        // When HomeView invokes FileCollectorTask and setOnFailed is triggered.
        if (eitherFileSystemScanResult.isLeft()) {
            getChildren().add(ControlUtil.getBasicErrorComponent(eitherFileSystemScanResult.getLeft().getError()));
            return;
        }

        // FileCollectorTask CompletableFuture exceptionally triggered.
        FileSystemScanResult scanResult = eitherFileSystemScanResult.get();
        if (scanResult.getError().isPresent()) {
            getChildren().add(ControlUtil.getBasicErrorComponent(scanResult.getError().get()));
            return;
        }

        /*
         * FileSystemScanResult has no error which means modifiedFileResult and deletedFileResult are available.
         * But they are both of type Either which results in the following outcome.
         *
         * getFileAccessErrors and getModifiedAndDeletedFileScanResults work together to collect all displayable data.
         * - getFileAccessErrors collects all the errors - see javadoc.
         * - getModifiedAndDeletedFileScanResults combines the the modified and deleted FileChangeRecords only if they
         *   exist. This means an empty list could be returned which is fine since getFileAccessErrors will
         *   show all the corresponding errors providing the user with an idea of what went wrong.
         */
        ObservableList<FileAccessError> fileAccessErrors = getFileAccessErrors(eitherFileSystemScanResult.get());
        ObservableList<FileChangeRecord> fileSystemScanResults = getModifiedAndDeletedFileScanResults(eitherFileSystemScanResult.get());

        /*
         * Always show the files ready for backup pane even if there are 0 results. The title displays the number
         * of results which provides feedback to the user rather than creating a new label to display a 0 result message.
         * If there are results then the table view is added as the content.
         */
        filesReadyForBackupPane = new TitledPane();
        filesReadyForBackupPane.setText("Files ready for backup (" + fileSystemScanResults.size() + ")");
        filesReadyForBackupPane.setExpanded(false);

        /*
         * If no scan results exist, only the files ready for backup titled pane shows.
         *
         * If file scan results exist, add in the FileSystemScanResultsTable into the titled pane. A button to execute
         * the backup is also added in as the first control in this view. Additional statistic titled pane is also
         * included.
         *
         * It is decided to allow the backup to occur if there are errors. Its just that only the FileChangeRecords
         * displayed in FileSystemScanResultsTable will be executed in the backup. This allows the user to perform
         * a partial backup while having the option to re run the backup if there was temporary file system access issues.
         */
        if (fileSystemScanResults.isEmpty()) {
            getChildren().add(filesReadyForBackupPane);
            ControlUtil.fadeIn(filesReadyForBackupPane);
        } else {
            filesReadyForBackupPane.setContent(new FileSystemScanResultsTable(fileSystemScanResults));
            buttonExecuteBackup = new Button("Execute Backup");

            buttonExecuteBackup.setOnAction(e -> {
                // If there are file errors, this changes to be empty which doesn't call execute backup.
                Optional<ButtonType> selectedButton = Optional.of(ButtonType.OK);

                if (!fileAccessErrors.isEmpty()) {
                    Alert alert = new Alert(Alert.AlertType.CONFIRMATION, "There are errors which could result in data loss, " +
                            "do you wish to continue with the backup?");
                    selectedButton = alert.showAndWait()
                            .filter(response -> response == ButtonType.OK);
                }

                // wind back up and fade out view in readiness for this BackupActionView to be replaced with BackupExecutionResultsView.
                if (filesReadyForBackupPane != null) {
                    filesReadyForBackupPane.setExpanded(false);
                }
                if (errorPane != null) {
                    errorPane.setExpanded(false);
                }
                ControlUtil.fadeOutThen(this, event -> getChildren().clear());

                selectedButton.ifPresent(b -> executeBackup());
            });


            getChildren().add(buttonExecuteBackup);

            if (eitherFileSystemScanResult.get().getModifiedFileResult().isRight() &&
                    eitherFileSystemScanResult.get().getDeletedFileResult().isRight()) {
                fileSystemScanStatisticsPane = new FileSystemScanStatisticsPane(eitherFileSystemScanResult.get());
            }

            if (fileSystemScanStatisticsPane != null) {
                getChildren().add(fileSystemScanStatisticsPane);
            }

            getChildren().add(filesReadyForBackupPane);
            ControlUtil.fadeIn(fileSystemScanStatisticsPane);
            ControlUtil.fadeIn(filesReadyForBackupPane);
            ControlUtil.fadeIn(buttonExecuteBackup);
        }

        // Only add the error pane if there are errors.
        if (!fileAccessErrors.isEmpty()) {
            errorPane = new TitledPane();
            errorPane.setText("Errors (" + fileAccessErrors.size() + ")");
            errorPane.setContent(new FileAccessErrorTableView(fileAccessErrors));
            errorPane.setExpanded(false);
            HBox.setHgrow(errorPane, Priority.ALWAYS);

            getChildren().add(errorPane);
            ControlUtil.fadeIn(errorPane);
        }

        // Expand panes once populated for ui feedback
        ControlUtil.doAfterDelay(Duration.millis(500), e -> {
            if (fileSystemScanStatisticsPane != null) {
                fileSystemScanStatisticsPane.setExpanded(true);
            }
            if (!fileSystemScanResults.isEmpty() && filesReadyForBackupPane != null) {
                filesReadyForBackupPane.setExpanded(true);
            }
            if (!fileAccessErrors.isEmpty() && errorPane != null) {
                errorPane.setExpanded(true);
            }
        });
    }

    /**
     * Displays file system analysis statistics. getModifiedFileResult and getDeletedFileResult are available as they
     * are verified prior to constructing an instance in the BackupActionView constructor.
     *
     * <p>Note: these statistics are based on what the {@code AbstractFileCollector}s gathers. For example, if
     * {@code ModifiedFileCollector} says its found 2 new directories, it doesn't necessarily indicate these will
     * be in the files ready for backup table view. Its purely an indication of new directories being found and its
     * most likely they will be created indirectly when a new file is created and non existing parent directories
     * are created at the same time.</p>
     */
    private class FileSystemScanStatisticsPane extends TitledPane {
        private FileSystemScanStatisticsPane(FileSystemScanResult fileSystemScanResult) {
            TableColumn<FileSystemScanResult, String> filesScannedColumn = new TableColumn<>("Files scanned");
            filesScannedColumn.setCellValueFactory(param ->
                    new SimpleStringProperty(param.getValue().getModifiedFileResult().get().getTotalFilesScanned() + ""));
            filesScannedColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<FileSystemScanResult, String> directoriesScannedColumn = new TableColumn<>("Directories scanned");
            directoriesScannedColumn.setCellValueFactory(param ->
                    new SimpleStringProperty(param.getValue().getModifiedFileResult().get().getTotalDirectoriesScanned() + ""));
            directoriesScannedColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<FileSystemScanResult, String> newFilesColumn = new TableColumn<>("New files");
            newFilesColumn.setCellValueFactory(param ->
                    new SimpleStringProperty(param.getValue().getModifiedFileResult().get().getTotalNewFiles() + ""));
            newFilesColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<FileSystemScanResult, String> newDirectoriesColumn = new TableColumn<>("New directories");
            newDirectoriesColumn.setCellValueFactory(param ->
                    new SimpleStringProperty(param.getValue().getModifiedFileResult().get().getTotalNewDirectories() + ""));
            newDirectoriesColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<FileSystemScanResult, String> filesModifiedColumn = new TableColumn<>("Files modified");
            filesModifiedColumn.setCellValueFactory(param ->
                    new SimpleStringProperty(param.getValue().getModifiedFileResult().get().getTotalFilesModified() + ""));
            filesModifiedColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<FileSystemScanResult, String> filesUnmodifiedColumn = new TableColumn<>("Files unmodified");
            filesUnmodifiedColumn.setCellValueFactory(param ->
                    new SimpleStringProperty(param.getValue().getModifiedFileResult().get().getTotalFilesUnmodified() + ""));
            filesUnmodifiedColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<FileSystemScanResult, String> filesDeletedColumn = new TableColumn<>("Files deleted");
            filesDeletedColumn.setCellValueFactory(param ->
                    new SimpleStringProperty(param.getValue().getDeletedFileResult().get().getTotalFilesDeleted() + ""));
            filesDeletedColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<FileSystemScanResult, String> directoriesDeletedColumn = new TableColumn<>("Directories deleted");
            directoriesDeletedColumn.setCellValueFactory(param ->
                    new SimpleStringProperty(param.getValue().getDeletedFileResult().get().getTotalDirectoriesDeleted() + ""));
            directoriesDeletedColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            FormattedTableView<FileSystemScanResult> tableView = new FormattedTableView<>();

            tableView.getColumns().add(filesScannedColumn);
            tableView.getColumns().add(directoriesScannedColumn);
            tableView.getColumns().add(newFilesColumn);
            tableView.getColumns().add(newDirectoriesColumn);
            tableView.getColumns().add(filesModifiedColumn);
            tableView.getColumns().add(filesUnmodifiedColumn);
            tableView.getColumns().add(filesDeletedColumn);
            tableView.getColumns().add(directoriesDeletedColumn);

            tableView.setItems(FXCollections.observableArrayList(fileSystemScanResult));

            setExpanded(false);
            setText("Statistics");
            setContent(tableView);
        }
    }

    /**
     * Displays the aggregated data from {@link #getModifiedAndDeletedFileScanResults}.
     */
    private class FileSystemScanResultsTable extends FormattedTableView<FileChangeRecord> {
        private FileSystemScanResultsTable(ObservableList<FileChangeRecord> data) {

            TableColumn<FileChangeRecord, String> fileSystemActionColumn = new TableColumn<>("File System Action");
            fileSystemActionColumn.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getFileSystemAction().getDescription()));
            fileSystemActionColumn.setCellFactory(param -> TableCellFactory.fileSystemActionTableCell());

            TableColumn<FileChangeRecord, String> currentPathColumn = new TableColumn<>("Current Path");
            currentPathColumn.setCellValueFactory(param -> param.getValue().getCurrentWorkingPath()
                    .map(path -> new SimpleStringProperty(path.toString()))
                    .orElseGet(() -> new SimpleStringProperty("Missing")));
            currentPathColumn.setCellFactory(param -> TableCellFactory.currentPathTableCell());

            TableColumn<FileChangeRecord, String> fileTypeColumn = new TableColumn<>("File Type");
            fileTypeColumn.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getFileType().getDescription()));
            fileTypeColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<FileChangeRecord, String> backupPathColumn = new TableColumn<>("Backup Path");
            backupPathColumn.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getBackupPath().toString()));
            backupPathColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<FileChangeRecord, String> currentLastModifiedColumn = new TableColumn<>("Current Last Modified");
            currentLastModifiedColumn.setCellValueFactory(param -> param.getValue().getCurrentLastModifiedTimeStamp()
                    .map(SimpleStringProperty::new)
                    .orElseGet(() -> new SimpleStringProperty("")));
            currentLastModifiedColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<FileChangeRecord, String> backupLastModified = new TableColumn<>("Backup Last Modified");
            backupLastModified.setCellValueFactory(param -> param.getValue().getBackupLastModifiedTimeStamp()
                    .map(SimpleStringProperty::new)
                    .orElseGet(() -> new SimpleStringProperty("")));
            backupLastModified.setCellFactory(param -> TableCellFactory.defaultTableCell());

            TableColumn<FileChangeRecord, String> modifiedSpanColumn = new TableColumn<>("Last Modified Span");
            modifiedSpanColumn.setCellValueFactory(param -> param.getValue().getModificationTimeDifference()
                    .map(SimpleStringProperty::new)
                    .orElseGet(() -> new SimpleStringProperty("")));
            modifiedSpanColumn.setCellFactory(param -> TableCellFactory.defaultTableCell());

            data.sort(Comparator.comparingInt(this::fileSystemScanResultsSortOrder));
            setItems(data);

            getColumns().add(fileSystemActionColumn);
            getColumns().add(fileTypeColumn);
            getColumns().add(currentPathColumn);
            getColumns().add(backupPathColumn);
            getColumns().add(currentLastModifiedColumn);
            getColumns().add(backupLastModified);
            getColumns().add(modifiedSpanColumn);
        }

        /**
         * Sort by new, modify then delete last.
         */
        private int fileSystemScanResultsSortOrder(FileChangeRecord record) {
            switch (record.getFileSystemAction()) {
                case New: return 1;
                case Modify: return 2;
                case Delete: return 3;
                default: return 0;
            }
        }
    }

    /**
     * Merges the modified and deleted file scan results into a {@code ObservableList} to be presented in a TableView.
     *
     * @param result The {@code FileSystemScanResult}.
     * @return The merged data sets.
     */
    private ObservableList<FileChangeRecord> getModifiedAndDeletedFileScanResults(FileSystemScanResult result) {
        ObservableList<FileChangeRecord> modifiedFiles = result.getModifiedFileResult()
                .map(records -> records.getFileChangeRecords().stream().collect(new ObservableListCollector<>()))
                .getOrElse(FXCollections.observableArrayList());

        List<FileChangeRecord> deletedFiles = result.getDeletedFileResult()
                .map(FileAnalysisResult::getFileChangeRecords)
                .getOrElse(new ArrayList<>());

        modifiedFiles.addAll(deletedFiles);
        return modifiedFiles;
    }

    /**
     * Merges all errors into a single {@code ObservableList} to be presented in a single TableView.
     *
     * <p>For example, {@code ModifiedFileCollector} could have failed to run resulting in
     * {@code FileSystemScanResult.modifiedFileResult} containing the error in Either.left. However if
     * {@code ModifiedFileCollector} was able to run, there can be potential errors during the file walking process which
     * are available by accessing Either.right to get access to the {@code ModifiedFileWalkerResult} which contains any
     * errors generated during the walking phase. This same logic is applied to the deleted file scan process.</p>
     *
     * @param result The {@code FileSystemScanResult}.
     * @return The merged errors.
     */
    private ObservableList<FileAccessError> getFileAccessErrors(FileSystemScanResult result) {
        ObservableList<FileAccessError> errors = FXCollections.observableArrayList();

        if (result.getModifiedFileResult().isLeft()) {
            errors.add(result.getModifiedFileResult().getLeft());
        } else {
            errors.addAll(result.getModifiedFileResult().get().getFileAccessErrors());
        }

        if (result.getDeletedFileResult().isLeft()) {
            errors.add(result.getDeletedFileResult().getLeft());
        } else {
            errors.addAll(result.getDeletedFileResult().get().getFileAccessErrors());
        }
        return errors;
    }

    private void executeBackup() {
        /*
         * eitherFileSystemScanResult.right exists as per the very first validation in constructor.
         *
         * We still need to ensure getModifiedFileResult and getDeletedFileResult contain FileChangeRecords
         * generated during successful file walking by ModifiedFileCollector and DeletedFileCollector. If this is not
         * the case, empty PendingXXX records are created and sent to the BackupExecutionTask which results in
         * BackupExecutor methods handling empty records fine without any null issues.
         */
        FileSystemScanResult fileSystemScanResult = eitherFileSystemScanResult.get();

        PendingModifiedRecords pendingModifiedRecords = fileSystemScanResult.getModifiedFileResult()
                .map(FileAnalysisResult::getFileChangeRecords)
                .map(PendingModifiedRecords::of)
                .getOrElse(PendingModifiedRecords.ofEmpty());

        PendingDeletedRecords pendingDeletedRecords = fileSystemScanResult.getDeletedFileResult()
                .map(FileAnalysisResult::getFileChangeRecords)
                .map(PendingDeletedRecords::of)
                .getOrElse(PendingDeletedRecords.ofEmpty());

        BackupExecutionTask backupExecutionTask = new BackupExecutionTask(pendingModifiedRecords, pendingDeletedRecords);

        // execute button is a 1 time operation, must go through backup flow again to enable it.
        buttonExecuteBackup.setDisable(true);
        homeView.bindDisableProperty(backupExecutionTask.runningProperty());
        homeView.getProgressStatus().start("Executing backup", backupExecutionTask.runningProperty());

        backupExecutionTask.setOnSucceeded(e -> {
            BackupExecutionResult backupExecutionResult = backupExecutionTask.getValue();
            homeView.setCenterView(new BackupExecutionResultView(Either.right(backupExecutionResult)));
        });

        backupExecutionTask.setOnFailed(value -> {
            TaskFailureError error = TaskFailureError.of("Backup execution task failed - rerun backup to view files that are pending backup");
            homeView.setCenterView(new BackupExecutionResultView(Either.left(error)));
        });

        FileBackupExecutorService.getInstance().get().submit(backupExecutionTask);
    }
}
